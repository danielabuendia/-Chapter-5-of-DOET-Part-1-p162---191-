# CHAPTER 5 OF DOET PART-1

## OVERVIEW
Chapter 5 argues that what we usually call “human error” is very often the result of **bad design**, not user failure. Norman explains that people make predictable kinds of errors, and because designers know these patterns, systems should be built to either prevent errors or help users recover from them quickly.

---

## TYPES OF ERRORS

### SLIPS
Slips occur when the user **has the correct goal or intention**, but performs the wrong action.

Slips happen because of:
- Attention failures  
- Distractions  
- Memory lapses  
- Actions that are too automatic  

**Examples:**
- Turning on the wrong stove burner
  
![This is the picture of a stove](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTGBbQmkIwLVbBWHvXEb4IT2GwiYjdhIt5fbA&s)
- Typing the wrong word even when you know the right one  
- Pressing “Delete” instead of “Save”
![This is the picture of a stove](https://miro.medium.com/v2/0*FP5HnVH_hTKk-kTE)  

Norman mentions categories such as:
- **Capture slips** (a more frequent behavior “captures” a less frequent one)  
- **Description-similarity slips** (controls or objects look too similar)  
- **Memory-lapse slips** (forgetting a step or interruption resets the task)

---

### MISTAKES
Mistakes occur when the **goal or plan itself is wrong**.  
This is not a typing issue — it’s a misunderstanding of the system.

Norman breaks mistakes into:
- **Rule-based mistakes**: The user chooses the wrong rule or applies a correct rule in the wrong situation.  
- **Knowledge-based mistakes**: The user lacks understanding and must problem-solve with incomplete information.  
- **Memory-lapse mistakes**: The user forgets important information needed for decision-making.

**Examples:**
- Misinterpreting a display because its design is confusing
![This is the picture of a stove](https://i5.walmartimages.com/seo/Universal-Remote-Replacement-For-Control-TV-For-TV-Controll_f9da8735-f4ee-4075-b26f-df88214ec489_1.b530f5c7892f8e01d18be6bbc74cc81a.jpeg?odnHeight=768&odnWidth=768&odnBg=FFFFFF  )  
- Using the wrong procedure because the system looks similar to another  
- Assuming a device works one way when it actually works another

---

## WHY ERRORS HAPPEN
Norman emphasizes that errors are not personal failures — they come from:
- Poor signifiers  
- Poor feedback  
- Bad mappings  
- Overly complex systems  
- Inconsistent interfaces  
- Situations that force users to rely on memory instead of cues

He explains that well-designed systems **should expect errors**, and even assume the user will make them.

---

## DESIGN PRINCIPLES FOR REDUCING ERRORS

### ADDING CONSTRAINTS
Systems can prevent errors by limiting what actions are possible.  
Examples include:
- Connectors that only fit one way  
- Controls that can’t be activated in the wrong sequence  
- Color-coding and size differences to prevent confusing similar components

---

### BETTER FEEDBACK
Clear, immediate feedback helps users understand what happened and where the error occurred.  
Bad or delayed feedback often makes errors worse.

---

### UNDO
One of the most powerful ways to reduce the consequences of error is the **Undo** function.  
Multiple levels of Undo can turn potential disasters into recoverable moments.

---

### CONFIRMATIONS
Systems can ask users to confirm dangerous or irreversible actions.  
Examples:
- “Are you sure you want to delete this file?”
 ![This is the picture of a stove]( https://discussions.apple.com/content/attachment/940977040)  
- Prompts before overwriting documents

Confirmations are a last line of defense when constraints or Undo are not enough.

---

## THE MAIN POINT
Norman’s central argument is simple:

**If a system allows users to make easy, predictable errors, the fault is in the design — not the human.**

Designers should:
- Understand human limitations  
- Anticipate likely errors  
- Build systems that guide users and help them recover  

Good design minimizes the chance of error and keeps mistakes from turning into disasters.

---

## PERSONAL REFLECTION
This chapter changed the way I think about mistakes. It’s comforting to realize that many errors come from design issues, not personal faults. After reading this, it becomes obvious how many interfaces rely too much on memory, have confusing layouts, or offer poor feedback.

In my own projects, this chapter reminds me to:
- Add helpful feedback  
- Avoid vague controls  
- Provide confirmation before destructive actions  
- Assume users will make mistakes — and design for that reality  

